face_name_regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/

function parse_cell_names(text) {
    let result = new Map();
    let lines = text.split(/\r?\n|;/g);
    lines.forEach((line) => {
        line = line.trim();
        if (line === "") {
            return;
        }
        let colonsplit = line.split(":");
        if (colonsplit.length != 2) {
            throw new Error(`couldn't parse "${line}"`);
        }
        let [dim_str, rest] = colonsplit;
        dim_str = dim_str.trim();
        if (!/^[-+]?\d+$/.test(dim_str)) {
            throw new Error(`couldn't parse dimension ${dim_str}`);
        }
        let dim = parseInt(dim_str);
        rest = rest.trim();
        if (rest.endsWith(",")) {
            rest = rest.slice(0, rest.length - 1).trim();
        }
        let names;
        if (rest === "") {
            names = [];
        }
        else {
            names = rest.split(",").map((s=>s.trim()));
            names.forEach((name) => {
                if (!face_name_regex.test(name)) {
                    throw new Error(`name ${name} is invalid`);
                }
            });
        }
        if (result.has(dim)) {
            throw new Error(`Multiple lines for dimension ${dim}`);
        }
        result.set(dim, names);
    });
    return result;
}

function parse_boundary(text) {
    // Example:
    // return new Map([
    //     ["x", [[1, "v"], [-1, "v"]]],
    //     ["y", [[1, "v"], [-1, "v"]]],
    //     ["F", [[1, "x"], [1, "y"], [1, "x"], [-1, "y"]]],
    // ]);
    let result = new Map();
    let lines = text.split(/\r?\n|;/g);
    lines.forEach((line) => {
        line = line.trim();
        if (line === "") {
            return;
        }
        let colonsplit = line.split(":");
        if (colonsplit.length != 2) {
            throw new Error(`couldn't parse "${line}"`);
        }
        let [name, rest] = colonsplit;
        name = name.trim();
        if (!face_name_regex.test(name)) {
            throw new Error(`name ${name} is invalid`);
        }
        if (result.has(name)) {
            throw new Error(`duplicate boundary entry for ${name}`)
        }
        rest = rest.trim();
        let chain;
        if (rest === "" || rest === "0") {
            result.set(name, []);
            return;
        }
        if (rest[0] !== "+" && rest[0] !== "-") {
            rest = "+" + rest;
        }
        splits = [0];
        for (i = 1; i < rest.length; i++) {
            let c = rest.charAt(i);
            if (c === "+" || c === "-") {
                splits.push(i);
            }
        }
        splits.push(rest.length);
        chain = [];
        for (j = 1; j < splits.length; j++) {
            let chunk = rest.slice(splits[j - 1], splits[j]);
            if (chunk === "") {
                throw new Error(`Duplicate +- in ${rest}`);
            }
            let sign = chunk.charAt(0) === "+" ? +1 : -1;
            let spaces = chunk.slice(1).search(/\S/);
            if (spaces === -1) {
                throw new Error("Empty face name");
            }
            let digits = chunk.slice(1 + spaces).search(/\D/);
            if (digits == -1) {
                throw new Error(`Integer ${chunk} is not a cell`);
            }
            let coeff = sign;
            if (digits > 0) {
                coeff *= parseInt(chunk.slice(1 + spaces, 1 + spaces + digits));
            }
            let boundary_name = chunk.slice(1 + spaces + digits).trim();
            if (!face_name_regex.test(boundary_name)) {
                throw new Error(`name ${boundary_name} is invalid`);
            }
            chain.push([coeff, boundary_name]);
        }
        result.set(name, chain);
    });
    return result;
}

function get_homology_result_string(cell_names_text, boundary_text, co) {
    let result = null;
    try {
        let cell_names = parse_cell_names(cell_names_text);
        let boundary = parse_boundary(boundary_text);
        result = homology_from_names(cell_names, boundary, co);
    }
    catch (err) {
        console.error(err);
        return "Error: " + err.message;
    }
    let string_result = [];
    result.forEach(([dim, {free_generators, torsion_generators}]) => {
        let head;
        if (co) {
            head = `H^${dim}:`
        }
        else {
            head = `H_${dim}:`
        }
        function print(s) {
            line = head + " ".repeat(6 - head.length) + s;
            string_result.push(line);
            head = "";
        }
        if (free_generators.length == 0 && torsion_generators.length == 0) {
            print("trivial");
        };
        free_generators.forEach((freegen) => {
            print(`a copy of ℤ generated by ${coeffs_to_string(freegen)}`);
        });
        torsion_generators.forEach(([torgen, order]) => {
            print(`a copy of ℤ/${order.toString()}ℤ generated by ${coeffs_to_string(torgen)}`);
        });
        string_result.push("");
    });
    return string_result.join("\r\n");
}

let cell_names_textarea = document.getElementById("cell_names");
let boundary_textarea = document.getElementById("boundary");
let output_textarea = document.getElementById("output_textarea");
let auto_check = document.getElementById("auto_check");
let co_check = document.getElementById("co_check");

function update() {
    output_textarea.value = "...";
    let result_string = get_homology_result_string(
        cell_names_textarea.value,
        boundary_textarea.value,
        co_check.checked);
    output_textarea.value = result_string;
}

function keystroke() {
    if (auto_check.checked) {
        update();
    }
    else {
        output_textarea.value = "";
    }
}
// https://stackoverflow.com/a/14029861/11461120
if (cell_names_textarea.addEventListener) {
    cell_names_textarea.addEventListener('input', keystroke, false);
    boundary_textarea.addEventListener('input', keystroke, false);
} else if (cell_names_textarea.attachEvent) {
    cell_names_textarea.attachEvent('onpropertychange', keystroke);
    boundary_textarea.addEventListener('onpropertychange', keystroke);
}
co_check.addEventListener('change', update);

function do_example(ex_name) {
    let [ex_names, ex_boundary] = EXAMPLES.get(ex_name);
    cell_names_textarea.value = ex_names;
    boundary_textarea.value = ex_boundary;
    update();
}

do_example("torus_delta");
